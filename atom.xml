<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Time渐行渐远]]></title>
  <link href="http://dmlcoding.com/atom.xml" rel="self"/>
  <link href="http://dmlcoding.com/"/>
  <updated>2018-04-27T15:38:18+08:00</updated>
  <id>http://dmlcoding.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[线性回归]]></title>
    <link href="http://dmlcoding.com/15248143200628.html"/>
    <updated>2018-04-27T15:32:00+08:00</updated>
    <id>http://dmlcoding.com/15248143200628.html</id>
    <content type="html"><![CDATA[
<p>小试牛刀,未完待续,精彩内容且看下回更新.</p>

<h2 id="toc_0">简述原理</h2>

<h2 id="toc_1">\(\theta\)值推导过程以及求解</h2>

<h3 id="toc_2">构造数据</h3>

<span id="more"></span><!-- more -->

<pre><code class="language-python">import numpy as np
import pandas as pd

# 构造测试数据y=3x1+x2
df=pd.DataFrame({
    &quot;x1&quot;:[1,2,3,4,5,6],
    &quot;x2&quot;:[1,2,1,2,1,2],
    &quot;y&quot;:[3,6,7,10,11,14]
})

</code></pre>

<h3 id="toc_3">抽取x和y</h3>

<pre><code class="language-python"># 抽取x和y
x=df[[&#39;x1&#39;,&#39;x2&#39;]]
# 将y转换成n行1列的列向量
y=df[&#39;y&#39;].values.reshape((-1,1))

</code></pre>

<h3 id="toc_4">求解\(\theta\) 值</h3>

<p><em>根据公式计算\(\theta\)</em>值,推导过程如图所示<br/>
\[\theta=(X^TX)^{-1}X^TY\]</p>

<p><em>numpy</em> api说明:<br/>
+ mat:将ndarray转成matrix<br/>
+ dot:矩阵乘法<br/>
+ T:求矩阵的转置<br/>
+ I:求矩阵的逆</p>

<pre><code class="language-python"># 写出公式,计算theta值

np.dot(np.mat(x.T.dot(x)).I,x.T).dot(y)
</code></pre>

<pre><code>matrix([[ 2.],
        [ 1.]])
</code></pre>

<p>很明显,计算结果正确.两个系数分别是2和1</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python-matplotlib画图中文显示不出来]]></title>
    <link href="http://dmlcoding.com/15242825563762.html"/>
    <updated>2018-04-21T11:49:16+08:00</updated>
    <id>http://dmlcoding.com/15242825563762.html</id>
    <content type="html"><![CDATA[
<pre><code>import matplotlib as mpl
import matplotlib.pyplot as plt

## 设置字符集，防止中文乱码
mpl.rcParams[&#39;font.sans-serif&#39;]=[u&#39;simHei&#39;]
mpl.rcParams[&#39;axes.unicode_minus&#39;]=False
</code></pre>

<span id="more"></span><!-- more -->

<p><img src="media/15242825563762/15242826157154.jpg" alt=""/></p>

<p>已经在代码中设置了字符集,但是却仍然无法正确显示.这是因为系统中没有这个字体</p>

<h1 id="toc_0">解决方案</h1>

<h2 id="toc_1">1. 下载SimHei.ttf字体</h2>

<pre><code>http://www.fontpalace.com/font-details/SimHei/
</code></pre>

<h2 id="toc_2">2. 查看matplotlib的字体存放目录</h2>

<pre><code>/Users/hushiwei/anaconda3/lib/python3.6/site-packages/matplotlib/mpl-data
</code></pre>

<pre><code>total 64
drwxr-xr-x   6 hushiwei  staff    192  1 18 12:03 ./
drwxr-xr-x  86 hushiwei  staff   2752  1 18 12:03 ../
drwxr-xr-x   5 hushiwei  staff    160  1 18 12:03 fonts/
drwxr-xr-x  58 hushiwei  staff   1856  1 18 12:03 images/
-rw-rw-r--   2 hushiwei  staff  31975 10 10  2017 matplotlibrc
drwxr-xr-x  27 hushiwei  staff    864  1 18 12:03 stylelib/
</code></pre>

<h2 id="toc_3">3. 导入字体,删除缓存</h2>

<p>将我们刚刚下载好的字体,<code>SimHei.ttf</code>文件​，放在matplotlib的font目录（./matplotlib/mpl-data/fonts/ttf/）或者系统的font目录下都行(/usr/share/fonts/)</p>

<p>接着:<br/>
​删除/Users/hushiwei/.matplotlib/*目录，重新运行你的画图脚本；此时程序会自动在~/.matplotlib目录下生成fontList.json文件；</p>

<h2 id="toc_4">4. 重启jupyter ,重新执行代码.</h2>

<p>OK,完成....<br/>
<img src="media/15242825563762/15242830696194.jpg" alt=""/></p>

<h1 id="toc_5">总结</h1>

<ol>
<li>需要在代码中引入字符集.</li>
<li>系统中需要有这个字体.</li>
<li>导入字体后,若要生效,需要先删除~/.matplotlib目录,让这个目录中的文件重新生成.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown中用LaTex语法写数学公式]]></title>
    <link href="http://dmlcoding.com/15235878044126.html"/>
    <updated>2018-04-13T10:50:04+08:00</updated>
    <id>http://dmlcoding.com/15235878044126.html</id>
    <content type="html"><![CDATA[
<p>最近在学习机器学习和神经网络的一些知识, 在用Markdown做笔记的时候, 发现公式用到LaTeX十分方便, 写篇文章记录在学习过程中的常用的LaTeX公式和用法, 因为本博客支持MathJax, <code>MathJax</code>是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，MathJax可以解析<code>Latex</code>、<code>MathML</code>和<code>ASCIIMathML</code>的标记语言。</p>

<!--more-->

<h2 id="toc_0">关键字索引</h2>

<p><code>\</code> 或者<code>~</code>: 空格</p>

<p><code>\verb +text+</code> : 直接打印不执行任何LATEX命令。这里的+仅是分隔符的一个例子, 除了* 或空格，可以使用任意一个字符。</p>

<p><code>\url{www.baidu.com}</code> : 嵌入超链接, 可在文档中点击访问</p>

<p><code>\emph{text}</code> : 强调的内容</p>

<p><code>\section{...}</code> : 章</p>

<p><code>\subsection{...}</code> : 节</p>

<p><code>\subsubsection{...}</code> : 子节</p>

<p><code>\paragraph{...}</code> : 段落</p>

<p><code>\subparagraph{...}</code> : 子段落</p>

<p>`<code>text&#39;</code> : 单引号</p>

<p><code>text&#39;&#39;</code> : 双引号引起来的text</p>

<p><code>--</code> : 折线</p>

<h2 id="toc_1">基本概念</h2>

<ul>
<li><p>控制序列: 以<code>\</code>开头,参数：<code>必须参数{}</code>和<code>可选参数[]</code></p></li>
<li><p>环境: 以<code>bengin 环境名</code>开始，并以<code>end 环境名</code>结束</p></li>
<li><p>文本模式:如果你想要在公式中排版普通的文本，那么你必须要把这些文本放在<code>\textrm{...}</code> 命令中</p></li>
<li><p>数学模式</p></li>
</ul>

<ol>
<li><p>内嵌模式:公式直接放在文字之间，公式高度一般受文本高度限制: <code>$ latex $</code></p>

<blockquote>
<p>文字\(\sum_{i=0}^{n}i^2\) 文字</p>
</blockquote></li>
<li><p>独立模式:公式另起一行，高度可调整</p>

<blockquote>
<p>文字\[\sum_{i=0}^{n}i^2\]文字</p>
</blockquote></li>
</ol>

<blockquote>
<p>在LaTeX中，花括号是用于分组，即花括号内部文本为一组, 大括号能消除二义性, 一个组即单个字符或者使用{..}包裹起来的内容。</p>
</blockquote>

<h3 id="toc_2">上标与下标</h3>

<ul>
<li><p>上标<code>^{角标}</code>，下标<code>_{角标}</code>, 默认情况下，上下标符号仅仅对下一个组起作用。</p>

<p><code>x_1</code> : \(x_1\) </p>

<p><code>x_1^2</code> : \(x_1^2\) </p>

<p><code>x^{2_1}</code> : \(x^{2_1}\) </p>

<p><code>x_{(22)}^{(n)}</code> : \(x_{(22)}^{(n)}\)</p></li>
</ul>

<h3 id="toc_3">分式</h3>

<ul>
<li><p><code>\frac{分子}{分母}</code></p>

<p><code>\frac ab</code> : \(\frac ab\)</p>

<p><code>\frac{x+y}{2}</code> : \(\frac{x+y}{2}\)</p>

<p><code>\frac{1}{1+\frac{1}{2}}</code> : \(\frac{1}{1+\frac{1}{2}}\)</p></li>
</ul>

<h3 id="toc_4">根式</h3>

<ul>
<li><p>开平方：<code>\sqrt{表达式}</code>；开n次方：<code>\sqrt[n]{表达式}</code></p>

<p><code>\sqrt{2}&lt;\sqrt[3]{3}</code> : \(\sqrt{2}&lt;\sqrt[3]{3}\)</p>

<p><code>\sqrt[4]{\frac xy}</code> ：\(\sqrt[4]{\frac xy} \)</p>

<p><code>\sqrt{1+\sqrt[^p]{1+a^2}}</code> : \(\sqrt{1+\sqrt[^p]{1+a^2}}\)</p></li>
</ul>

<h3 id="toc_5">求和与积分</h3>

<ul>
<li><p>求和<code>\sum</code> ; 求积分<code>\int</code>; 上下限就是<code>上标和下标</code></p>

<p><code>\int_1^\infty</code> ：\(\int_1^\infty\)</p>

<p><code>\int_a^b f(x)dx</code> : \(\int_a^b f(x)dx\)</p>

<p><code>\sum_1^n</code> ：\(\sum_1^n\)</p>

<p><code>\sum_{k=1}^n\frac{1}{k}</code> : \(\sum_{k=1}^n\frac{1}{k}\)</p></li>
</ul>

<h3 id="toc_6">微分</h3>

<p><code>\frac{\partial E_w}{\partial w}</code> : \(\frac{\partial E_w}{\partial w}\)</p>

<p>\[\frac{\partial E_\hat{w}}{\partial \hat{w}}= 2X^T(X\vec{\hat{w}}-\vec{y}) = 0\]</p>

<h3 id="toc_7">加粗</h3>

<p><code>\mathbf{x}_i :</code>\(\mathbf{x}_i\)</p>

<h3 id="toc_8">多重积分</h3>

<ul>
<li>对于多重积分，不要使用<code>\int\int</code>此类的表达，应该使用<code>\iint</code>,<code>\iiint</code>等特殊形式。效果如下：</li>
</ul>

<p>\[<br/>
\begin{array}{cc}<br/>
\mathrm{Bad} &amp; \mathrm{Better} \\\\<br/>
\hline \\\\<br/>
\int\int_S f(x)\,dy\,dx &amp; \iint_S f(x)\,dy\,dx \\\\<br/>
\int\int\int_V f(x)\,dz\,dy\,dx &amp; \iiint_V f(x)\,dz\,dy\,dx<br/>
\end{array}<br/>
\]</p>

<ul>
<li>在微分前应该使用<code>\</code>,来增加些许空间，否则\(\TeX\)会将微分紧凑地排列在一起。如下：</li>
</ul>

<p>\[<br/>
\begin{array}{cc}<br/>
\mathrm{Bad} &amp; \mathrm{Better} \\\\<br/>
\hline \\\\<br/>
\iiint_V f(x)dz dy dx &amp; \iiint_V f(x)\,dz\,dy\,dx<br/>
\end{array}<br/>
\]</p>

<h2 id="toc_9">特殊函数与符号</h2>

<ol>
<li>常见的三角函数，求极限符号可直接使用<code>\+</code>缩写即可
<code>\sin x</code> , <code>\arctan x</code>, <code>\lim_{1\to\infty}</code> : \(\sin x\),\(\arctan x\),\(\lim_{1\to\infty}\)</li>
<li>比较运算符：
<code>\lt \gt \le \ge \neq</code> ： \(\lt \gt \le \ge \neq\)

<ul>
<li>在这些运算符前面加上<code>\not</code>
<code>\not\lt</code> ：\(\not\lt\)</li>
</ul></li>
<li><code>\times \div \pm \mp</code> ：\(\times \div \pm \mp\)
<code>\cdot</code>表示居中的点
<code>x \cdot y</code> : \(x \cdot y\)。</li>
<li>集合关系与运算
<code>\cup \cap \setminus \subset \subseteq \subsetneq \supset \in \notin \emptyset \varnothing</code> ：\(\cup 
\cap \setminus \subset \subseteq \subsetneq \supset \in \notin \emptyset \varnothing\)</li>
<li>排列
<code>{n+1 \choose 2k}</code> : \({n+1 \choose 2k}\) 
<code>\binom{n+1}{2k}</code> : \({n+1 \choose 2k}\)</li>
<li>箭头：
<code>\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto</code> : \(\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto\)</li>
<li>逻辑运算符
<code>\land \lor \lnot \forall \exists \top \bot \vdash \vDash</code> ：\(\land \lor \lnot \forall \exists \top \bot \vdash \vDash\)</li>
<li><code>\star \ast \oplus \circ \bullet</code> ： \(\star \ast \oplus \circ \bullet\)</li>
<li><code>\approx \sim \cong \equiv \prec</code> ： \(\approx \sim \cong \equiv \prec\)</li>
<li><code>\infty \aleph_0</code> : \(\infty  \aleph_0\) 
<code>\nabla \partial</code> : \(\nabla \partial\) \Im \Re \(Im \Re\)</li>
<li>模运算 <code>\pmode</code> 
<code>a\equiv b\pmod n</code> ：\(a\equiv b\pmod n\)</li>
<li><code>\ldots与\cdots</code>区别是dots的位置不同，ldots位置稍低，cdots位置居中
<code>a_1+a_2+\cdots+a_n</code> : \(a_1+a_2+\cdots+a_n\)
<code>a_1, a_2, \ldots ,a_n</code> : \(a_1, a_2, \ldots ,a_n\)。</li>
<li><p>一些希腊字母具有变体形式<br/>
<code>\epsilon \varepsilon</code> : \( \epsilon \varepsilon\)<br/>
<code>\phi \varphi</code> : \(\phi \varphi\)</p></li>
</ol>

<ul>
<li>使用<a href="http://detexify.kirelabs.org/classify.html">Detexify</a>在网页上画出符号，Detexify会给出相似的符号及其代码但是不能保证它给出的符号可以在MathJax中使用，你可以参考<a href="http://docs.mathjax.org/en/latest/tex.html#supported-latex-commands">supported-latex-commands</a>确定MathJax是否支持此符号。</li>
</ul>

<h2 id="toc_10">空格 : 美化公式</h2>

<p>紧贴<code>a!b</code> : \(a!b\)<br/>
  没有空格<code>ab</code> : \(ab\)<br/>
  小空格<code>a\,b</code> : \(a\,b\)<br/>
  中等空格<code>a\;b</code> : \(a\;b\)<br/>
  大空格<code>a\ b</code> : \(a\ b\)<br/>
  quad空格<code>a\quad b</code> : \(a\quad b\)<br/>
  两个quad空格<code>a\qquad b</code> : \(a\qquad b\)</p>

<p>原公式:<code>\int_a^b f(x)\mathrm{d}x</code><br/>
  \(\int_a^b f(x)\mathrm{d}x\)</p>

<p>插入空格:<code>\int_a^b f(x)\qquad \mathrm{d}x</code><br/>
  \(\int_a^b f(x)\qquad \mathrm{d}x\)</p>

<h2 id="toc_11">括号</h2>

<ol>
<li>小括号与方括号：使用原始的<code>( )</code>，<code>[ ]</code>即可，如<code>(2+3)[4+4]</code>：\((2+3)[4+4]\)</li>
<li>大括号：时由于大括号{}被用来分组，使用\lbrace 和\rbrace来表示
<code>\lbrace a*b \rbrace</code> ：\(\lbrace a*b \rbrace\)</li>
<li>尖括号：使用<code>\langle</code> 和 <code>\rangle</code>表示左尖括号和右尖括号
<code>\langle x \rangle</code> ：\(\langle x \rangle\)</li>
<li>上取整：使用<code>\lceil</code> 和 <code>\rceil</code> 表示 
<code>\lceil x \rceil</code> ：\(\lceil x \rceil\)</li>
<li>下取整：使用<code>\lfloor</code> 和 <code>\rfloor</code> 表示
<code>\lfloor x \rfloor</code> ：\(\lfloor x \rfloor\)</li>
<li><p>不可见括号：使用<code>.</code>表示</p></li>
</ol>

<ul>
<li><p>注意 : 原始符号并不会随着公式大小缩放。如，<code>(\frac12)</code> ：\((\frac12)\)。可以使用\left(…\right)来自适应的调整括号大小。<br/>
如1.1和1.2公式，公式1.2中的括号是经过缩放的。</p>

<p><code>\lbrace \sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6} \rbrace \tag{1.1}</code><br/>
\[\lbrace\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}\rbrace\tag{1.1}\]</p>

<p><code>\left \lbrace \sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6} \right\rbrace \tag{1.2}</code><br/>
\[\left \lbrace \sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6} \right\rbrace\tag{1.2}\]</p></li>
<li><p>定界符之前冠以 \left（修饰左定界符）或 \right（修饰右定界符），可以得到自适应缩放的定界符，它们会根据定界符所包围的公式大小自适应缩放</p>

<p><code>\left( \sum_{k=\frac{1}{2}}^{N^2}\frac{1}{k} \right)</code><br/>
\[ \left( \sum_{k=\frac{1}{2}}^{N^2}\frac{1}{k} \right) \]</p></li>
</ul>

<h2 id="toc_12">字体</h2>

<ol>
<li>使用<code>\mathbb</code>或<code>\Bbb</code>显示黑板粗体字，此字体经常用来表示代表实数、整数、有理数、复数的大写字母。
<code>\mathbb{CHNQRZ}</code> : \(\mathbb{CHNQRZ}\)。</li>
<li>使用<code>\mathbf</code>显示黑体字
<code>\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$，$\mathbf{abcdefghijklmnopqrstuvwxyz}</code>
\(\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\)，\(\mathbf{abcdefghijklmnopqrstuvwxyz}\)</li>
<li>使用<code>\mathtt</code>显示打印机字体
<code>\mathtt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$，$\mathtt{abcdefghijklmnopqrstuvwxyz}</code>
\(\mathtt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\)，\(\mathtt{abcdefghijklmnopqrstuvwxyz}\)</li>
<li>使用<code>\mathrm</code>显示罗马字体
<code>\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$，$\mathrm{abcdefghijklmnopqrstuvwxyz}</code>
\(\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\)，\(\mathrm{abcdefghijklmnopqrstuvwxyz}\)</li>
<li>使用<code>\mathscr</code>显示手写体, 无小写
<code>\mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}, $\mathscr{abcdefghijklmnopqrstuvwxyz}</code>
\(\mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}, \)\mathscr{abcdefghijklmnopqrstuvwxyz}$</li>
<li>使用<code>\mathfrak</code>显示Fraktur字母（一种德国字体）
<code>\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$, $\mathfrak{abcdefghijklmnopqrstuvwxyz}</code>
\(\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\),\(\mathfrak{abcdefghijklmnopqrstuvwxyz}\)</li>
</ol>

<h2 id="toc_13">方程组</h2>

<ul>
<li><p>使用<code>\begin{array} ... \end{array}</code>与<code>\left\{…\right.</code>配合，表示方程组</p></li>
<li><p>使用 <code>\being{aligned} .. \end{aligned}</code></p></li>
</ul>

<p>\[<br/>
\begin{aligned}<br/>
\dot{x} &amp; = \sigma(y-x) \\\<br/>
\dot{y} &amp; = \rho x - y - xz \\\<br/>
\dot{z} &amp; = -\beta z + xy<br/>
\end{aligned}<br/>
\]</p>

<ul>
<li>使用 <code>\being{case} .. \end{case}</code></li>
</ul>

<p>\[<br/>
\begin{cases}<br/>
a_1x+b_1y+c_1z=d_1 \\\<br/>
a_2x+b_2y+c_2z=d_2 \\\<br/>
a_3x+b_3y+c_3z=d_3<br/>
\end{cases}<br/>
\]</p>

<ul>
<li>对齐方程组中的<code>=</code>号, 注意<code>{</code>要转义,&#39;\{&#39;</li>
</ul>

<p>\[ \left\\{<br/>
     \begin{aligned} <br/>
       a_1x+b_1y+c_1z &amp;=d_1+e_1 \\\<br/>
       a_2x+b_2y&amp;=d_2 \\\ <br/>
       a_3x+b_3y+c_3z &amp;=d_3 <br/>
\end{aligned} <br/>
\right. <br/>
\]</p>

<ul>
<li>如果要对齐 <code>=</code>号和<code>项</code>，可以使用<code>\being{array}{列样式} .. \end{array}</code></li>
</ul>

<p>\[<br/>
\left\\{<br/>
\begin{array}{ll}<br/>
a_1x+b_1y+c_1z &amp;=d_1+e_1 \\\<br/>
a_2x+b_2y &amp;=d_2 \\\<br/>
a_3x+b_3y+c_3z &amp;=d_3 <br/>
\end{array} <br/>
\right.<br/>
\]</p>

<h3 id="toc_14">上下文字</h3>

<p>\[ \mathop {\arg min }\limits_{(w,b)}^{top} f(x)\]</p>

<h3 id="toc_15">公式标记与引用</h3>

<ul>
<li>使用<code>\tag{tag}</code>来标记公式，如果想在之后引用该公式，则还需要加上<code>\label{label}</code>在<code>\tag</code>之后，如：</li>
<li>需要<code>\*</code>对标签<code>*</code>进行转义</li>
</ul>

<p>\[<br/>
 a := x^2-y^3 \tag{\*}\label{\*}<br/>
\]</p>

<p>\[<br/>
 a := x^2-y^3 \tag{2.1}\label{2.1}<br/>
\]</p>

<ul>
<li>为了引用公式，可以使用<code>\eqref{rlabel}</code>，如：</li>
</ul>

<p>\[a+y^3 \stackrel{\eqref{\*}}= x^2\]</p>

<p>\[a+y^3 \stackrel{\eqref{2.1}}= x^2\]</p>

<ul>
<li>通过超链接可以跳转到被引用公式位置。</li>
</ul>

<h3 id="toc_16"><strong>矩阵</strong></h3>

<ul>
<li><p>使用<code>$$\begin{matrix}…\end{matrix}$$</code>表示矩阵，矩阵的行之间使用<code>\\\</code>分隔，列之间使用<code>&amp;</code>分隔。</p></li>
<li><p>效果如下 :</p></li>
</ul>

<p>\[<br/>
        \begin{matrix}<br/>
        1 &amp; x &amp; x^2 \\\<br/>
        1 &amp; y &amp; y^2 \\\<br/>
        1 &amp; z &amp; z^2 \\\<br/>
        \end{matrix}<br/>
\]</p>

<ul>
<li><strong>加括号</strong>
如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\left</code>与<code>\right</code>配合表示括号符号。也可以使用特殊的<code>matrix</code>。即替换<code>\begin{matrix}...\end{matrix}</code>中的matrix为<code>pmatrix</code>，<code>bmatrix</code>，<code>Bmatrix</code>，<code>vmatrix</code>,<code>Vmatrix</code></li>
</ul>

<p><code>pmatrix</code> : \(\begin{pmatrix}1&amp;2\\\3&amp;4\\\ \end{pmatrix}\) <br/>
<code>bmatrix</code> : \(\begin{bmatrix}1&amp;2\\\3&amp;4\\\ \end{bmatrix}\) <br/>
<code>Bmatrix</code> : \(\begin{Bmatrix}1&amp;2\\\3&amp;4\\\ \end{Bmatrix}\) <br/>
<code>vmatrix</code> : \(\begin{vmatrix}1&amp;2\\\3&amp;4\\\ \end{vmatrix}\) <br/>
<code>Vmatrix</code> : \(\begin{Vmatrix}1&amp;2\\\3&amp;4\\\ \end{Vmatrix}\) </p>

<ul>
<li><strong>省略元素</strong>  使用<code>\cdots</code> : \(\cdots\) <code>\ddots</code> : \(\ddots\)  <code>\vdots</code> : \(\vdots\)来省略矩阵中的元素</li>
</ul>

<p>\[<br/>
    \begin{pmatrix}<br/>
         1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\\<br/>
         1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\\<br/>
         \vdots  &amp; \vdots&amp; \vdots &amp; \ddots &amp; \vdots \\\<br/>
         1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n <br/>
    \end{pmatrix}<br/>
\]</p>

<h3 id="toc_17"><strong>增广矩阵</strong></h3>

<ul>
<li>增广矩阵需要使用前面的<code>array</code>来实现</li>
</ul>

<p>\[ \left[<br/>
      \begin{array}{cc|c}<br/>
        1&amp;2&amp;3\\\<br/>
        4&amp;5&amp;6<br/>
      \end{array}<br/>
    \right]<br/>
\]</p>

<h3 id="toc_18"><strong>对齐公式</strong></h3>

<ul>
<li>使用形如<code>\begin{align}…\end{align}</code>的格式，使用&amp;来指示需要对齐的位置</li>
</ul>

<p>\[<br/>
    \begin{align}<br/>
    \sqrt{37} &amp; = \sqrt{\frac{73^2-1}{12^2}} \\\<br/>
     &amp; = \sqrt{\frac{73^2}{12^2}\cdot\frac{73^2-1}{73^2}} \\\<br/>
     &amp; = \sqrt{\frac{73^2}{12^2}}\sqrt{\frac{73^2-1}{73^2}} \\\<br/>
     &amp; = \frac{73}{12}\sqrt{1 - \frac{1}{73^2}} \\\<br/>
     &amp; \approx \frac{73}{12}\left(1 - \frac{1}{2\cdot73^2}\right)<br/>
    \end{align}<br/>
\]</p>

<h3 id="toc_19"><strong>分类表达式</strong></h3>

<ul>
<li>定义函数时分情况给出表达式，使用<code>\begin{cases}…\end{cases}</code></li>
<li>使用<code>\\\</code>来分类，使用<code>&amp;</code>指示需要对齐的位置</li>
</ul>

<p>\[<br/>
 f(n) =<br/>
    \begin{cases}<br/>
    n/2,  &amp; \text{if $n$ is even} \\\\[2ex]<br/>
    3n+1, &amp; \text{if $n$ is odd}<br/>
    \end{cases}<br/>
\]</p>

<ul>
<li><code>[4ex]</code>控制分类之间的垂直间隔, 这里要用<code>\\\\</code>转义</li>
</ul>

<h3 id="toc_20"><strong>表格</strong></h3>

<ul>
<li>使用<code>$$\begin{array}{列样式}...\end{array}$$</code>创建表格</li>
<li>列样式使用<code>clr</code>表示居中，左，右对齐</li>
<li>使用<code>|</code>表示一条竖线</li>
<li>使用<code>\\\\</code>分隔行，使用<code>&amp;</code>分隔列</li>
<li>使用<code>\hline</code>在本行前加入一条直线</li>
</ul>

<p>\[<br/>
    \begin{array}{c|lcr}<br/>
    n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \\\\<br/>
    \hline<br/>
    1 &amp; 0.24 &amp; 1 &amp; 125 \\\\<br/>
    2 &amp; -1 &amp; 189 &amp; -8 \\\\<br/>
    3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\<br/>
    \end{array}<br/>
\]</p>

<ul>
<li>复杂列表</li>
</ul>

<h3 id="toc_21"><strong>希腊字母</strong></h3>

<table>
<thead>
<tr>
<th>名称</th>
<th>大写</th>
<th>Tex</th>
<th>小写</th>
<th>Tex</th>
</tr>
</thead>

<tbody>
<tr>
<td>alpha</td>
<td>\(A\)</td>
<td>A</td>
<td>\(\alpha\)</td>
<td>\alpha</td>
</tr>
<tr>
<td>beta</td>
<td>\(B\)</td>
<td>B</td>
<td>\(\beta\)</td>
<td>\beta</td>
</tr>
<tr>
<td>gamma</td>
<td>\(\Gamma\)</td>
<td>\Gamma</td>
<td>\(\gamma\)</td>
<td>\gamma</td>
</tr>
<tr>
<td>delta</td>
<td>\(\Delta\)</td>
<td>\Delta</td>
<td>\(\delta\)</td>
<td>\delta</td>
</tr>
<tr>
<td>epsilon</td>
<td>\(E\)</td>
<td>E</td>
<td>\(\epsilon\)</td>
<td>\epsilon</td>
</tr>
<tr>
<td>zeta</td>
<td>\(Z\)</td>
<td>Z</td>
<td>\(\zeta\)</td>
<td>\zeta</td>
</tr>
<tr>
<td>eta</td>
<td>\(H\)</td>
<td>H</td>
<td>\(\eta\)</td>
<td>\eta</td>
</tr>
<tr>
<td>theta</td>
<td>\(\Theta\)</td>
<td>\Theta</td>
<td>\(\theta\)</td>
<td>\theta</td>
</tr>
<tr>
<td>iota</td>
<td>\(I\)</td>
<td>I</td>
<td>\(\iota\)</td>
<td>\iota</td>
</tr>
<tr>
<td>kappa</td>
<td>\(K\)</td>
<td>K</td>
<td>\(\kappa\)</td>
<td>\kappa</td>
</tr>
<tr>
<td>lambda</td>
<td>\(\Lambda\)</td>
<td>\Lambda</td>
<td>\(\lambda\)</td>
<td>\lambda</td>
</tr>
<tr>
<td>mu</td>
<td>\(M\)</td>
<td>M</td>
<td>\(\mu\)</td>
<td>\mu</td>
</tr>
<tr>
<td>nu</td>
<td>\(N\)</td>
<td>N</td>
<td>\(\nu\)</td>
<td>\nu</td>
</tr>
<tr>
<td>xi</td>
<td>\(\Xi\)</td>
<td>\Xi</td>
<td>\(\xi\)</td>
<td>\xi</td>
</tr>
<tr>
<td>omicron</td>
<td>\(O\)</td>
<td>O</td>
<td>\(\omicron\)</td>
<td>\omicron</td>
</tr>
<tr>
<td>pi</td>
<td>\(\Pi\)</td>
<td>\Pi</td>
<td>\(\pi\)</td>
<td>\pi</td>
</tr>
<tr>
<td>rho</td>
<td>\(P\)</td>
<td>P</td>
<td>\(\rho\)</td>
<td>\rho</td>
</tr>
<tr>
<td>sigma</td>
<td>\(\Sigma\)</td>
<td>\Sigma</td>
<td>\(\sigma\)</td>
<td>\sigma</td>
</tr>
<tr>
<td>tau</td>
<td>\(T\)</td>
<td>T</td>
<td>\(\tau\)</td>
<td>\tau</td>
</tr>
<tr>
<td>upsilon</td>
<td>\(\Upsilon\)</td>
<td>\Upsilon</td>
<td>\(\upsilon\)</td>
<td>\upsilon</td>
</tr>
<tr>
<td>phi</td>
<td>\(\Phi\)</td>
<td>\Phi</td>
<td>\(\phi\)</td>
<td>\phi</td>
</tr>
<tr>
<td>chi</td>
<td>\(X\)</td>
<td>X</td>
<td>\(\chi\)</td>
<td>\chi</td>
</tr>
<tr>
<td>psi</td>
<td>\(\Psi\)</td>
<td>\Psi</td>
<td>\(\psi\)</td>
<td>\psi</td>
</tr>
<tr>
<td>omega</td>
<td>\(\Omega \)</td>
<td>\Omega</td>
<td>\(\omega\)</td>
<td>\omega</td>
</tr>
</tbody>
</table>

<h3 id="toc_22"><strong>重音符号</strong></h3>

<ul>
<li><p><code>\hat{A}</code> : \( \hat{A} \)</p></li>
<li><p>单字符<br/>
<code>\hat</code> ：\(\hat x\)</p></li>
<li><p>多字符<br/>
<code>\widehat</code> : \(\widehat {xy}\)</p></li>
</ul>

<p><img src="media/15235878044126/15235930010630.jpg" alt=""/></p>

<h3 id="toc_23"><strong>二元关系</strong></h3>

<ul>
<li><code>a\ll{b}</code> : \( a\ll{b} \)</li>
</ul>

<p><img src="media/15235878044126/15235930296134.jpg" alt=""/></p>

<h3 id="toc_24"><strong>二元运算符</strong></h3>

<ul>
<li><code>\pm</code> : \( \pm \)</li>
</ul>

<p><img src="media/15235878044126/15235930579186.jpg" alt=""/></p>

<h3 id="toc_25"><strong>&quot;大&quot;运算符</strong></h3>

<ul>
<li><code>\sum</code> : \( \sum \)</li>
</ul>

<p><img src="media/15235878044126/15235931068818.jpg" alt=""/></p>

<h3 id="toc_26"><strong>箭头</strong></h3>

<ul>
<li><code>\to</code> : \( \to \)</li>
</ul>

<p><img src="media/15235878044126/15235931161176.jpg" alt=""/></p>

<h3 id="toc_27"><strong>定界符</strong></h3>

<ul>
<li><code>\lbrack</code> : \( \lbrack \)</li>
</ul>

<p><img src="media/15235878044126/15235931287395.jpg" alt=""/></p>

<h3 id="toc_28"><strong>大定界符</strong></h3>

<ul>
<li><code>\lgroup</code> : \( \lgroup \)</li>
</ul>

<p><img src="media/15235878044126/15235931644817.jpg" alt=""/></p>

<h3 id="toc_29"><strong>其他符号</strong></h3>

<ul>
<li><code>\dots</code> : \( \dots \)</li>
</ul>

<p><img src="media/15235878044126/15235931801879.jpg" alt=""/></p>

<h3 id="toc_30"><strong>注意事项</strong></h3>

<ul>
<li><p>不要在再指数或者积分中使用 <code>\frac</code></p></li>
<li><p>在指数或者积分表达式中使用<code>\frac</code>会使表达式看起来不清晰，应该使用一个水平的<code>/</code>来代替</p></li>
<li><p>使用 \mid 代替 | 作为分隔符<br/>
符号|作为分隔符时有排版空间大小的问题，应该使用\mid代替。效果如下：</p></li>
</ul>

<p>\[<br/>
\begin{array}<br/>
\mathrm{Bad} &amp; \mathrm{Better} \\\<br/>
\hline \\\<br/>
{x|x^2\in\Bbb Z} &amp; {x\mid x^2\in\Bbb Z} \\\<br/>
\end{array}<br/>
\]</p>

<ul>
<li>连分数
书写连分数表达式时，请使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>,两者效果对比如下：</li>
</ul>

<p>\[<br/>
x = a_0 + \cfrac{1^2}{a_1<br/>
          \+ \cfrac{2^2}{a_2<br/>
          \+ \cfrac{3^2}{a_3 + \cfrac{4^4}{a_4 + \cdots}}}} \tag{\cfrac}<br/>
\]<br/>
\[<br/>
x = a_0 + \frac{1^2}{a_1<br/>
         \+ \frac{2^2}{a_2<br/>
          \+ \frac{3^2}{a_3 + \frac{4^4}{a_4 + \cdots}}}} \tag{\frac}<br/>
\]</p>

<blockquote>
<p><strong>转义</strong><br/>
  一些MathJax使用的特殊字符，可以使用<code>\</code>或者<code>\\</code>转义为原来的含义。如<code>\$</code>表示<code>$</code>，<code>\\_</code>表示下划线。<br/>
- 注意: 换行和方程组的开始<code>{</code>等, 常常需要转义, 用<code>\</code>或者<code>\\</code>或者<code>\\\</code>或者<code>\\\\</code><br/>
<a href="https://github.com/Simshang/blog/blob/master/source/_posts/Demo-LaTeX.md">Markdown文件</a></p>
</blockquote>

<h3 id="toc_31">转载参考:<a href="http://simtalk.cn/2015/12/21/Demo-LaTeX/">http://simtalk.cn/2015/12/21/Demo-LaTeX/</a></h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何优雅的设计数据分层]]></title>
    <link href="http://dmlcoding.com/15228352753621.html"/>
    <updated>2018-04-04T17:47:55+08:00</updated>
    <id>http://dmlcoding.com/15228352753621.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">理论</h1>

<p><img src="media/15228352753621/15231557165878.jpg" alt=""/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">1.ODS 全称是 Operational Data Store，操作数据存储</h2>

<p>“面向主题的”，数据运营层，也叫ODS层，是最接近数据源中数据的一层，数据源中的数据，经过抽取、洗净、传输，也就说传说中的 ETL 之后，装入本层。本层的数据，总体上大多是按照源头业务系统的分类方式而分类的。</p>

<p>但是，这一层面的数据却不等同于原始数据。在源数据装入这一层时，要进行诸如去噪（例如有一条数据中人的年龄是 300 岁，这种属于异常数据，就需要提前做一些处理）、去重（例如在个人资料表中，同一 ID 却有两条重复数据，在接入的时候需要做一步去重）、字段命名规范等一系列操作。</p>

<h2 id="toc_2">2.数据仓库层(DW)，是数据仓库的主体</h2>

<p>在这里，从 ODS 层中获得的数据按照主题建立各种数据模型。这一层和维度建模会有比较深的联系.</p>

<h2 id="toc_3">3.数据产品层（APP），这一层是提供为数据产品使用的结果数据</h2>

<p>在这里，主要是提供给数据产品和数据分析使用的数据，一般会存放在 ES、Mysql 等系统中供线上系统使用，也可能会存在 Hive 或者 Druid 中供数据分析和数据挖掘使用。<br/>
比如我们经常说的报表数据，或者说那种大宽表，一般就放在这里</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark-Metrics 实战]]></title>
    <link href="http://dmlcoding.com/15224029526508.html"/>
    <updated>2018-03-30T17:42:32+08:00</updated>
    <id>http://dmlcoding.com/15224029526508.html</id>
    <content type="html"><![CDATA[
<p><a href="http://metrics.dropwizard.io/3.1.0/getting-started/">http://metrics.dropwizard.io/3.1.0/getting-started/</a><br/>
<a href="http://metrics.dropwizard.io/3.1.0/manual/core/">http://metrics.dropwizard.io/3.1.0/manual/core/</a><br/>
<a href="http://wuchong.me/blog/2015/08/01/getting-started-with-metrics/">http://wuchong.me/blog/2015/08/01/getting-started-with-metrics/</a></p>

<h2 id="toc_0">使用</h2>

<p>The –files flag will cause /path/to/metrics.properties to be sent to every executor,<br/>
and spark.metrics.conf=metrics.properties will tell all executors to load that file<br/>
when initializing their respective MetricsSystems.</p>

<p>直接添加到命令行后</p>

<pre><code>--files=/yourPath/metrics.properties 
--conf spark.metrics.conf=metrics.properties

</code></pre>

<h2 id="toc_1">小示例</h2>

<p>新建<code>metrics.properties</code>文件,内容如下</p>

<pre><code>
driver.source.jvm.class=org.apache.spark.metrics.source.JvmSource
executor.source.jvm.class=org.apache.spark.metrics.source.JvmSource

*.sink.console.class=org.apache.spark.metrics.sink.ConsoleSink
*.sink.console.period=10
*.sink.console.unit=seconds
</code></pre>

<p>全是driver端的信息</p>

<p><img src="media/15224029526508/15224033134708.jpg" alt=""/></p>

<h3 id="toc_2">jmx-sink</h3>

<pre><code>master.source.jvm.class=org.apache.spark.metrics.source.JvmSource
worker.source.jvm.class=org.apache.spark.metrics.source.JvmSource
driver.source.jvm.class=org.apache.spark.metrics.source.JvmSource
executor.source.jvm.class=org.apache.spark.metrics.source.JvmSource
*.sink.jmx.class=org.apache.spark.metrics.sink.JmxSink
</code></pre>

<p>spark on yarn 查看 </p>

<p><a href="http://u007:8089/proxy/application_1509616075703_478985/metrics/json">http://u007:8089/proxy/application_1509616075703_478985/metrics/json</a></p>

<h2 id="toc_3">总结</h2>

<p>source里面定义从哪些实例来监控</p>

<p>sink指定你要输出到哪里</p>

<p>刚才这个例子里面,就是sink输出到console</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark Metrics分析]]></title>
    <link href="http://dmlcoding.com/15223141973169.html"/>
    <updated>2018-03-29T17:03:17+08:00</updated>
    <id>http://dmlcoding.com/15223141973169.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">MetricsSystem类注释翻译</h2>

<p><img src="media/15223141973169/15223151043399.jpg" alt=""/></p>

<span id="more"></span><!-- more -->

<p>Spark Metrics System 结合源代码由特定的&quot;实例&quot;创建.<br/>
Sink,定期的拉取source中的度量数据(metrics data)到目标sink中.</p>

<p>&quot;实例&quot;指定&quot;谁&quot;(角色)使用metrics system.在spark中有几个角色,比如master,worker,executor,client driver.这些角色会创建度量系统进行监控.<br/>
所以实例代表这些角色.目前在spark中,已经实现了几个实例:master,worker,executor,driver,application.</p>

<p>&quot;Source&quot;指定&quot;从哪里&quot;(来源)去收集指标数据.在度量系统中,这存在两种来源:<br/>
1.Spark内部源,如MasterSource,WorkerSource等.它们将收集Spark组件的内部状态,这些源与实例相关,并将在创建特定度量标准系统后添加.<br/>
2.通用源,比如JvmSource,这些将收集低级别的状态,由配置进行配置并通过反射加载.</p>

<p>&quot;Sink&quot;指定将Metrics data 输出到哪里(目的地).多个sinks可以共存并且metrics可以都flush到这些sinks中.</p>

<p>Metrics配置格式如下所示</p>

<pre><code>[instance].[sink|source].[name].[options] = xxxx
</code></pre>

<p>[instance]可以是&quot;master&quot;,&quot;worker&quot;,&quot;executor&quot;,&quot;driver&quot;,&quot;applications&quot;这意味着只有指定的实例才具有这个属性.可以用&quot;*&quot;来替换实例名,这意味着所有的这些实例将拥有此属性.</p>

<p>[sink|source]表示此属性是属于source还是sink.这个字段只能是source或者sink.</p>

<p>[name] 指定source或者sink的名字.如果它是自定义的.</p>

<p>[options] 代表这个source或者sink的具体属性</p>

<h2 id="toc_1">Metrics系统</h2>

<p>Spark拥有一个基于Coda Hale Metrics Library的可配置Metrics系统,这个Metrics系统通过配置文件进行配置。</p>

<p>Spark的Metrics系统允许用户把Spark metrics信息报告到各种各样的sink包含HTTP和 JMX、CSV文件。</p>

<p>Spark的metrics系统解耦到每个Spark组件的实例中。每个实例里，你可以配置一组sink（metrics被报告到的地方）。</p>

<p>注：Coda Hale Metrics使用的Yammer.com开发的Metrics框架，官方网址是<a href="https://github.com/dropwizard/metrics">https://github.com/dropwizard/metrics</a> ，相关文档可在<a href="https://dropwizard.github.io/metrics">https://dropwizard.github.io/metrics</a> 查看。</p>

<h2 id="toc_2">配置文件</h2>

<p>默认的配置文件为“$SPARK_HOME/conf/metrics.properties”，Spark启动时候会自动加载它。</p>

<p>如果想修改配置文件位置，可以使用java的运行时属性<code>-Dspark.metrics.conf=xxx</code>进行修改。。</p>

<h2 id="toc_3">Spark的Metrics系统支持的实例：</h2>

<ul>
<li><p>master：Spark standalone模式的 master进程。</p></li>
<li><p>applications：master进程里的一个组件，为各种应用作汇报.</p></li>
<li><p>worker：Spark standalone模式的一个worker进程。</p></li>
<li><p>executor：一个Spark executor.</p></li>
<li><p>driver：Spark driver进程(该进程指创建SparkContext的那个).</p></li>
</ul>

<h2 id="toc_4">Spark的Metrics系统支持的Sink：</h2>

<p>　　Sink指定metrics信息发送到哪，每个instance可以设置一个或多个Sink。</p>

<p>　　Sink源码位于包org.apache.spark.metrics.sink中。</p>

<h3 id="toc_5">ConsoleSink</h3>

<p>　　记录Metrics信息到Console中。</p>

<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>class</td>
<td>org.apache.spark.metrics.sink.ConsoleSink</td>
<td>Sink类</td>
</tr>
<tr>
<td>period</td>
<td>10</td>
<td>轮询间隔</td>
</tr>
<tr>
<td>unit</td>
<td>seconds</td>
<td>轮询间隔的单位</td>
</tr>
</tbody>
</table>

<h3 id="toc_6">CSVSink</h3>

<p>　　定期的把Metrics信息导出到CSV文件中。</p>

<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>class</td>
<td>org.apache.spark.metrics.sink.CsvSink</td>
<td>Sink类</td>
</tr>
<tr>
<td>period</td>
<td>10</td>
<td>轮询间隔</td>
</tr>
<tr>
<td>unit</td>
<td>seconds</td>
<td>轮询间隔的单位</td>
</tr>
<tr>
<td>directory</td>
<td>/tmp</td>
<td>CSV文件存储的位置</td>
</tr>
</tbody>
</table>

<h3 id="toc_7">JmxSink</h3>

<p>可以通过JMX方式访问Mertics信息</p>

<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>class</td>
<td>org.apache.spark.metrics.sink.JmxSink</td>
<td>Sink类</td>
</tr>
</tbody>
</table>

<h3 id="toc_8">MetricsServlet</h3>

<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>class</td>
<td>org.apache.spark.metrics.sink.MetricsServlet</td>
<td>Sink类</td>
</tr>
<tr>
<td>path</td>
<td>VARIES*</td>
<td>Path prefix from the web server root</td>
</tr>
<tr>
<td>sample</td>
<td>false</td>
<td>Whether to show entire set of samples for histograms (&#39;false&#39; or &#39;true&#39;) ｜</td>
</tr>
</tbody>
</table>

<p>　　除master之外所有实例的默认路径为“/metrics/json”。</p>

<p>　　master有两个路径: “/metrics/aplications/json” App的信息、 “/metrics/master/json” Master的信息</p>

<h3 id="toc_9">GraphiteSink</h3>

<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>class</td>
<td>org.apache.spark.metrics.sink.GraphiteSink</td>
<td>Sink类</td>
</tr>
<tr>
<td>host</td>
<td>NONE</td>
<td>Graphite服务器主机名</td>
</tr>
<tr>
<td>port</td>
<td>NONE</td>
<td>Graphite服务器端口</td>
</tr>
<tr>
<td>period</td>
<td>10</td>
<td>轮询间隔</td>
</tr>
<tr>
<td>unit</td>
<td>seconds</td>
<td>轮询间隔的单位</td>
</tr>
<tr>
<td>prefix</td>
<td>EMPTY STRING</td>
<td>Prefix to prepend to metric name</td>
</tr>
</tbody>
</table>

<h3 id="toc_10">GangliaSink</h3>

<p>由于Licene限制，默认没有放到默认的build里面。需要自己打包</p>

<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>class</td>
<td>org.apache.spark.metrics.sink.GangliaSink</td>
<td>Sink类</td>
</tr>
<tr>
<td>host</td>
<td>NONE</td>
<td>Ganglia 服务器的主机名或multicast group</td>
</tr>
<tr>
<td>port</td>
<td>NONE</td>
<td>Ganglia服务器的端口</td>
</tr>
<tr>
<td>period</td>
<td>10</td>
<td>轮询间隔</td>
</tr>
<tr>
<td>unit</td>
<td>seconds</td>
<td>轮询间隔的单位</td>
</tr>
<tr>
<td>ttl</td>
<td>1</td>
<td>TTL of messages sent by Ganglia</td>
</tr>
<tr>
<td>mode</td>
<td>multicast</td>
<td>Ganglia网络模式(&#39;unicast&#39; or &#39;multicast&#39;)</td>
</tr>
</tbody>
</table>

<h2 id="toc_11">source：</h2>

<p>第一种为Spark内部source，MasterSource、WorkerSource等，它们会接收Spark组件的内部状态；<br/>
　　第二种为通用source，如：JvmSource，它收集低级别的状态</p>

<h2 id="toc_12">示例</h2>

<h3 id="toc_13">通过类名为所有实例开启ConsoleSink</h3>

<pre><code>*.sink.console.class=org.apache.spark.metrics.sink.ConsoleSink

ConsoleSink的轮询周期 *.sink.console.period=10

*.sink.console.unit=seconds

**Master实例重置轮询周期**

master.sink.console.period=15

master.sink.console.unit=seconds
</code></pre>

<h3 id="toc_14">通过类名为所有实例开启JmxSink</h3>

<pre><code>*.sink.jmx.class=org.apache.spark.metrics.sink.JmxSink
</code></pre>

<h3 id="toc_15">为所有实例开启CsvSink</h3>

<pre><code>*.sink.csv.class=org.apache.spark.metrics.sink.CsvSink
</code></pre>

<p><strong>CsvSink的轮询周期</strong></p>

<pre><code>*.sink.csv.period=1

*.sink.csv.unit=minutes
</code></pre>

<p>Polling directory for CsvSink *.sink.csv.directory=/tmp/</p>

<p><strong>Worker实例重置轮询周期</strong></p>

<pre><code>worker.sink.csv.period=10

worker.sink.csv.unit=minutes
</code></pre>

<h3 id="toc_16">为master和worker、driver、executor开启jvm source</h3>

<pre><code>
master.source.jvm.class=org.apache.spark.metrics.source.JvmSource

worker.source.jvm.class=org.apache.spark.metrics.source.JvmSource

driver.source.jvm.class=org.apache.spark.metrics.source.JvmSource

executor.source.jvm.class=org.apache.spark.metrics.source.JvmSource
</code></pre>

<h2 id="toc_17">参考文档：</h2>

<pre><code>${SPARK_HOME}/conf/metrics.properties.template
http://spark.apache.org/docs/latest/monitoring.html
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop RPC运行机制]]></title>
    <link href="http://dmlcoding.com/15222053353935.html"/>
    <updated>2018-03-28T10:48:55+08:00</updated>
    <id>http://dmlcoding.com/15222053353935.html</id>
    <content type="html"><![CDATA[
<p>RPC是一种通过网络从远程计算机上请求服务的机制，封装了具体实现，使用户不需要了解底层网络技术。目前存在许多开源RPC框架，比较有名的有Thrift、Protocol Buffers和Avro。Hadoop RPC与他们一样，均由两部分组成：对象序列化和远程过程调用</p>

<p>什么是远程过程调用?</p>

<span id="more"></span><!-- more -->

<p>首先从字面上解释，“过程”在Java中指的就是对象中的方法，“远程”是指不同机器上的进程（狭义），或者不同的进程（广义）（为了简单，下文不对这种情况进行说明）。因此，RPC就是允许程序调用其他机器上的对象方法。</p>

<p>RPC是属于典型的C/S结构，提供服务的一方称为server，请求服务的一方称为client。server端提供对象方法供client端调用，被调用的对象方法的执行发生在server端。</p>

<p>上面这样解释其实已经很明白了,为了更直观的理解.<br/>
那么就不废话了,直接上一个例子,用代码说话.</p>

<h1 id="toc_0">RPC 实例</h1>

<blockquote>
<p>简单来说,就是在client调用远程服务器里面的方法就像在本地调用自己的方法一样.</p>
</blockquote>

<p>我们的实例用hadoop rpc框架,那么我们需要引入对应的依赖</p>

<pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;
        &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;
        &lt;version&gt;2.7.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>

<p>Hadoop RPC主要由三个大类组成，即RPC、Client和Server，分别对应对外编程接口、客户端实现和服务器实现</p>

<p>代码分为两部分</p>

<ul>
<li>服务端的逻辑代码(server-rpc)</li>
<li>客户端调用服务端的逻辑代码(client-rpc)</li>
</ul>

<p><img src="media/15222053353935/15222165453483.jpg" alt=""/></p>

<h3 id="toc_1">服务端server-rpc</h3>

<p>RPCLearningServiceInterface <br/>
定义一个接口,我们想要客户端调用的方法</p>

<pre><code>/**
 * Created by hushiwei on 2018/3/28.
 * desc : RPC协议是client端和server端之间的通信接口，它定义了server端对外提供的服务接口。
 */
public interface RPCLearningServiceInterface {

    // 协议版本号,不同版本号的client和sever之间不能相互通信
    static final long versionID = 1L;

    // 登录方法
    String loging(String name);

    // 乘法
    String multip(int a, int b);
}


</code></pre>

<p>RPCLearningServiceImpl</p>

<p>接口的具体实现类</p>

<pre><code>/**
 * Created by hushiwei on 2018/3/28.
 * desc :Hadoop RPC协议通常是一个Java接口，定义了server端对外提供的服务接口，需要在server端进行实现
 *
 * server端的协议实现中不需要关注Socket通信
 *
 */
public class RPCLearningServiceImpl implements RPCLearningServiceInterface {
    @Override
    public String loging(String name) {
        System.out.println(&quot;Exec Login function ...&quot;);
        return &quot;Hello, &quot; + name + &quot;. Welcome you!&quot;;
    }

    @Override
    public String multip(int a, int b) {
        System.out.println(&quot;Prepare to exec multip function in server ....&quot;);
        return a + &quot; * &quot; + b + &quot; = &quot; + a * b;
    }
}

</code></pre>

<p>RpcLearningServer</p>

<p>server-rpc的启动类</p>

<pre><code>
/**
 * Created by hushiwei on 2018/3/28.
 * desc :
 *
 * java -classpath MapReduce-1.0-SNAPSHOT-jar-with-dependencies.jar com.hushiwei.mr.rpc.rpcserver.RpcLearningServer
 */
public class RpcLearningServer {
    public static void main(String[] args) throws IOException {

        // 创建RPC.Builder实例builder,用于构造RPC server
        RPC.Builder builder = new RPC.Builder(new Configuration());

        // 向builder传递一些必要的参数,如主机,端口号,真实业务逻辑实例,协议接口
        builder.setBindAddress(&quot;localhost&quot;).setPort(45666)
                .setInstance(new RPCLearningServiceImpl())
                .setProtocol(RPCLearningServiceInterface.class);

        // 构造rpc server
        RPC.Server server = builder.build();

        // 启动server
        server.start();

    }
}

</code></pre>

<h3 id="toc_2">客户端client-rpc</h3>

<p>ClientController</p>

<p>客户端的代码里面调用了服务端提供的api</p>

<pre><code>/**
 * Created by hushiwei on 2018/3/28.
 * desc : ClientController is a RPC client
 */
public class ClientController {
    public static void main(String[] args) throws IOException {

        // 通过rpc拿到loginServiceinterface的代理对象
        RPCLearningServiceInterface service = RPC.getProxy(RPCLearningServiceInterface.class, 1L, new InetSocketAddress(&quot;localhost&quot;, 45666), new Configuration());

        // 像本地调用一样,就可以调用服务端的方法
        String result = service.loging(&quot;Hushiwei&quot;);
        System.out.println(&quot;rpc client result: &quot; + result);

        String res = service.multip(6, 8);
        System.out.println(res);


        // 关闭连接
        RPC.stopProxy(service);
    }
}


</code></pre>

<h3 id="toc_3">本地执行</h3>

<ul>
<li>为了方便,我在本机进行测试,服务器地址写的localhost</li>
<li>我在idea中进行开发的,直接run起来</li>
</ul>

<p>运行<code>RpcLearningServer</code>类,启动rpc服务<br/>
<img src="media/15222053353935/15222166749600.jpg" alt=""/></p>

<p>运行<code>ClientController</code>类,启动client,进行远程调用<br/>
<img src="media/15222053353935/15222167326547.jpg" alt=""/></p>

<p>此时,看服务端的输出<br/>
<img src="media/15222053353935/15222167785896.jpg" alt=""/></p>

<p>这个也说明了,远程调用过程是在服务端执行的.</p>

<h3 id="toc_4">远程执行</h3>

<p>刚刚在本地执行的,为了更说明问题.我把服务器地址从<code>localhost</code>改成服务器的主机名<code>u006</code>,然后代码编译打包,上传到服务器上.<br/>
在远程服务器上启动rpc-server.然后再本地执行客户端的代码.<br/>
这样更能清楚的明白rpc的运行过程了</p>

<pre><code>java -classpath MapReduce-1.0-SNAPSHOT-jar-with-dependencies.jar com.hushiwei.mr.rpc.rpcserver.RpcLearningServer
</code></pre>

<p><img src="media/15222053353935/15222171711365.jpg" alt=""/></p>

<p>在服务器上启动了rpc-server,现在客户端还没启动,服务器上也没有任何输出.</p>

<p>接着在本地执行客户端代码<br/>
<img src="media/15222053353935/15222172448137.jpg" alt=""/></p>

<p>紧跟着,服务器上也有相应的输出了.<br/>
<img src="media/15222053353935/15222172751812.jpg" alt=""/></p>

<p>补充:<br/>
在服务器上启动rpcserver后,可以用<code>jps -m</code>查看这个服务器的启动情况</p>

<pre><code>[hadoop@U006 ~]$ jps -m
30432 Jps -m
6979 RpcLearningServer
</code></pre>

<p>或者查看代码里面用的端口是否被占用中</p>

<pre><code>[hadoop@U006 ~]$ netstat -natp | grep 45666
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 ::ffff:10.10.25.13:45666    :::*                        LISTEN      6979/java
</code></pre>

<p>是不是很熟悉,我们曾经安装hadoop后,用<code>jps -m</code>也可以看到hadoop里面的一些进程.比如<br/>
<code>NameNode</code>、<code>DataNode</code>、<code>ResourceManager</code>、<code>NodeManager</code>.</p>

<p>所以这些进程都是作为一个RPCserver,并对外提供RPC服务的.</p>

<h1 id="toc_5">总结</h1>

<p>定义RPC协议,实现RPC协议<br/>
<img src="media/15222053353935/15222165453483.jpg" alt=""/></p>

<p>构造并启动RPC服务<br/>
<img src="media/15222053353935/15222174334242.jpg" alt=""/></p>

<p>构成RPC客户端并发送RPC请求<br/>
<img src="media/15222053353935/15222173920962.jpg" alt=""/></p>

<p>使用Hadoop RPC的4个步骤</p>

<ul>
<li>定义RPC协议</li>
<li>实现RPC协议</li>
<li>构造并启动RPC server</li>
<li>构造RPC client并发送RPC请求</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[概率分布函数和概率密度函数]]></title>
    <link href="http://dmlcoding.com/15221149143615.html"/>
    <updated>2018-03-27T09:41:54+08:00</updated>
    <id>http://dmlcoding.com/15221149143615.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>研究一个随机变量,不只要看它能取哪些值,更重要的是它取各种值的概率如何!</p>
</blockquote>

<ul>
<li>概率分布函数</li>
<li>概率密度函数</li>
</ul>

<h2 id="toc_0">离散型随机变量</h2>

<p>在理解这两个词之前</p>

<span id="more"></span><!-- more --> 

<ul>
<li>概率分布函数</li>
<li>概率密度函数</li>
</ul>

<p>先理解这两个词</p>

<ul>
<li>概率函数: 就是用函数的形式来表达概率.也叫分布律.</li>
<li>概率分布: 表达随机变量所有可能取值的分布情况.注意:是所有的取值</li>
<li>分布函数: 即,概率分布函数,</li>
</ul>

<p><img src="media/15221149143615/15221166166372.png" alt=""/></p>

<p>概率分布函数: 它是概率函数各个取值的累加结果.也叫累积概率函数</p>

<ul>
<li>分布函数</li>
</ul>

<h2 id="toc_1">连续型随机变量</h2>

<ul>
<li>概率密度函数: 等同于概率函数,why?</li>
</ul>

<p>在连续型随机变量中为啥要将概率函数叫成概率密度函数呢?<br/>
参考陈希孺老师所著的《概率论与数理统计》<br/>
<img src="media/15221149143615/15221159306143.png" alt=""/><br/>
<img src="media/15221149143615/15221159405543.png" alt=""/></p>

<p>概率密度函数用数学公式表示就是一个定积分的函数，定积分在数学中是用来求面积的，而在这里，你就把概率表示为面积即可！<br/>
<img src="media/15221149143615/15221159485806.png" alt=""/></p>

<p>左边是F(x)<code>连续型随机变量分布函数</code>画出的图形，右边是f(x)<code>连续型随机变量的概率密度函数</code>画出的图像，它们之间的关系就是，概率密度函数是分布函数的导函数。</p>

<p>两张图一对比，你就会发现，如果用右图中的面积来表示概率，利用图形就能很清楚的看出，哪些取值的概率更大！这样看起来是不是特别直观，特别爽！！所以，我们在表示连续型随机变量的概率时，用f(x)概率密度函数来表示，是非常好的！</p>

<h1 id="toc_2">参考</h1>

<p><a href="https://www.jianshu.com/p/b570b1ba92bb">应该如何理解概率分布函数和概率密度函数?</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式系统的一致性]]></title>
    <link href="http://dmlcoding.com/15220339795263.html"/>
    <updated>2018-03-26T11:12:59+08:00</updated>
    <id>http://dmlcoding.com/15220339795263.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15220339795263/15221454798314.jpg" alt=""/></p>

<p>先上个图,未完待续......</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[docker 错误]]></title>
    <link href="http://dmlcoding.com/15217143404677.html"/>
    <updated>2018-03-22T18:25:40+08:00</updated>
    <id>http://dmlcoding.com/15217143404677.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">net/http: TLS handshake timeout</h2>

<p>下载镜像的时候出现<code>net/http: TLS handshake timeout</code>,<br/>
原因是docker默认镜像拉取地址为国外仓库下载速度较慢，则会报错“net/http: TLS handshake timeout”。</p>

<span id="more"></span><!-- more -->

<p>此时，只需要将拉取地址改为国内镜像仓库即可。</p>

<p>标准格式为：</p>

<pre><code>$ docker pull registry.docker-cn.com/myname/myrepo:mytag
</code></pre>

<p>例：</p>

<pre><code>$ docker pull registry.docker-cn.com/library/ubuntu:16.04
</code></pre>

<p>为了永久性保留更改，您可以修改 /etc/docker/daemon.json 文件并添加上 registry-mirrors 键值。</p>

<pre><code>{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}
</code></pre>

<p>修改保存后重启 Docker 以使配置生效。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac 搭建 区块链开发环境]]></title>
    <link href="http://dmlcoding.com/15216998348495.html"/>
    <updated>2018-03-22T14:23:54+08:00</updated>
    <id>http://dmlcoding.com/15216998348495.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="https://docs.docker.com/docker-for-mac/install/">官方安装文档</a></li>
<li><a href="https://docs.docker.com/docker-for-mac/">官方使用文档</a></li>
</ul>

<span id="more"></span><!-- more -->

<h1 id="toc_0">用docker下载ubuntu镜像</h1>

<pre><code># 下载ubuntu镜像
docker pull ubuntu
# 进入镜像中
docker run -it ubuntu /bin/bash
# 查看ubuntu的发行版本
cat /etc/issue

</code></pre>

<p>新开一个终端查看</p>

<pre><code> hushiwei@hsw  ~/Docker  docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
ubuntu                latest              f975c5035748        2 weeks ago         112MB
</code></pre>

<h2 id="toc_1">进入镜像后,即生成了一个容器.更新容易里面的系统</h2>

<p>跟新apt-get,安装常用开发工具</p>

<pre><code>apt-get update
apt-get install vim
apt-get install sudo
</code></pre>

<h2 id="toc_2">提高安全意识,添加普通用户</h2>

<pre><code>adduser deploy
su deploy
</code></pre>

<h2 id="toc_3">给普通用户sudo权限</h2>

<pre><code># root下执行
chmod 777 /etc/sudoers
vim /etc/sudoers
</code></pre>

<p>在/etc/sudoers文件里面添加一行,表示给deploy用户sudo权限,并且不需要密码<br/>
<img src="media/15216998348495/15217671764613.jpg" alt=""/></p>

<p>把这个文件的权限改回去</p>

<pre><code>chmod 440 /etc/sudoers
</code></pre>

<h1 id="toc_4">在容器中进行区块链环境的搭建</h1>

<p>注意:目前为止,我们还没退出容器过.</p>

<h2 id="toc_5">安装curl,nodejs</h2>

<pre><code>sudo apt-get install curl

# 安装nodejs的版本
root@a43d121b81a0:~# curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -
# 完成后输出
## Run `apt-get install nodejs` (as root) to install Node.js v8.x LTS Carbon and npm

# 然后安装nodejs
apt-get install nodejs

# 查看版本
node -v

npm -v
</code></pre>

<h2 id="toc_6">安装testrpc,truffle</h2>

<pre><code># 安装淘宝镜像,速度快
npm install -g cnpm --registry=https://registry.npm.taobao.org

sudo cnpm install -g ethereumjs-testrpc
# 完成后输入testrpc,进行校验

sudo cnpm install -g truffle

</code></pre>

<h1 id="toc_7">提交安装好环境的容器</h1>

<p>在开一个窗口,输入<code>docker ps</code> 找到正在运行的容器的<code>CONTAINER ID</code><br/>
刚刚在这个容器里面安装好了环境,那么我们需要保存一下,所以用docker commit提交这个<br/>
容器,成为镜像<br/>
<code><br/>
docker commit a43d121b81a0 testrpc-truffle-env:v1<br/>
</code><br/>
提交后,再查看images,比之前的ubuntu大了不少.毕竟装了那么多工具进去了<br/>
<code><br/>
 hushiwei@hsw  ~/Docker  docker images<br/>
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE<br/>
testrpc-truffle-env   v1                  a2073b0b64cc        6 minutes ago       503MB<br/>
ubuntu                latest              f975c5035748        2 weeks ago         112MB<br/>
</code></p>

<h2 id="toc_8">退出再进去</h2>

<p>现在就算退出运行中的容器,之前安装的工具也都还在了.<br/>
执行下面的命令即可进入刚刚提交的镜像中.<code>a2073b0b64cc</code>是刚刚提交的镜像的id</p>

<pre><code>docker run -it a2073b0b64cc /bin/bash
</code></pre>

<h1 id="toc_9">安装idea插件进行开发</h1>

<p>在idea的Plugins中安装插件<code>Intellij-Solidity</code></p>

<h1 id="toc_10">docker挂载本地目录进行开发</h1>

<p>将本地的<code>/Users/hushiwei/BlockChain/ethereum</code>目录,与容器中的<code>/home/deploy</code>进行共享</p>

<pre><code>docker run -it -v /Users/hushiwei/BlockChain/ethereum:/home/deploy a2073b0b64cc /bin/bash

</code></pre>

<h1 id="toc_11">生成truffle代码</h1>

<p>在容器的<code>/home/deploy/demo3</code>目录下执行<code>truffle init</code> 生成项目</p>

<p><img src="media/15216998348495/15217712425759.jpg" alt=""/></p>

<p>本机对应的目录也可以看到<br/>
<img src="media/15216998348495/15217712751901.jpg" alt=""/></p>

<h2 id="toc_12">用idea打开ethereum目录作为项目.</h2>

<p><img src="media/15216998348495/15217713264100.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode解题思路]]></title>
    <link href="http://dmlcoding.com/15216328231070.html"/>
    <updated>2018-03-21T19:47:03+08:00</updated>
    <id>http://dmlcoding.com/15216328231070.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">Easy</h1>

<span id="more"></span><!-- more -->

<h2 id="toc_1"><u>01</u>TwoSum</h2>

<h2 id="toc_2"><u>07</u>ReverseInteger</h2>

<h2 id="toc_3"><u>09</u>PalindromeNumber</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Macbook 区块链开发]]></title>
    <link href="http://dmlcoding.com/15216132281232.html"/>
    <updated>2018-03-21T14:20:28+08:00</updated>
    <id>http://dmlcoding.com/15216132281232.html</id>
    <content type="html"><![CDATA[
<p>基本概念就不说了,网上一大堆.</p>

<h2 id="toc_0">客户端安装</h2>

<pre><code>brew tap ethereum/ethereum

brew install ethereum

</code></pre>

<span id="more"></span><!-- more -->

<p>很是花了一些时间呢<br/>
<code><br/>
  /usr/local/Cellar/ethereum/1.8.2: 9 files, 54.7MB, built in 26 minutes 26 seconds<br/>
</code></p>

<pre><code>
geth -h
geth console

</code></pre>

<pre><code>
 hushiwei@hsw  ~/BlockChain  geth console
INFO [03-21|15:05:35] Maximum peer count                       ETH=25 LES=0 total=25
INFO [03-21|15:05:35] Starting peer-to-peer node               instance=Geth/v1.8.2-stable/darwin-amd64/go1.10
INFO [03-21|15:05:35] Allocated cache and file handles         database=/Users/hushiwei/Library/Ethereum/geth/chaindata cache=768 handles=1024
INFO [03-21|15:05:35] Initialised chain configuration          config=&quot;{ChainID: 1 Homestead: 1150000 DAO: 1920000 DAOSupport: true EIP150: 2463000 EIP155: 2675000 EIP158: 2675000 Byzantium: 4370000 Constantinople: &lt;nil&gt; Engine: ethash}&quot;
INFO [03-21|15:05:35] Disk storage enabled for ethash caches   dir=/Users/hushiwei/Library/Ethereum/geth/ethash count=3
INFO [03-21|15:05:35] Disk storage enabled for ethash DAGs     dir=/Users/hushiwei/.ethash                      count=2
INFO [03-21|15:05:35] Initialising Ethereum protocol           versions=&quot;[63 62]&quot; network=1
INFO [03-21|15:05:35] Loaded most recent local header          number=0 hash=d4e567…cb8fa3 td=17179869184
INFO [03-21|15:05:35] Loaded most recent local full block      number=0 hash=d4e567…cb8fa3 td=17179869184
INFO [03-21|15:05:35] Loaded most recent local fast block      number=0 hash=d4e567…cb8fa3 td=17179869184
INFO [03-21|15:05:35] Loaded local transaction journal         transactions=0 dropped=0
INFO [03-21|15:05:35] Regenerated local transaction journal    transactions=0 accounts=0
INFO [03-21|15:05:35] Starting P2P networking
INFO [03-21|15:05:37] UDP listener up                          self=enode://239405879cbf4f9d8cfb1dafca4bab87b8f7ce27fbdb486347d7215b1de56663805d520d44044bb5ed324a79e41fbdd0be2adbbe5f31684cf528bf2faef4796f@[::]:30303
INFO [03-21|15:05:37] RLPx listener up                         self=enode://239405879cbf4f9d8cfb1dafca4bab87b8f7ce27fbdb486347d7215b1de56663805d520d44044bb5ed324a79e41fbdd0be2adbbe5f31684cf528bf2faef4796f@[::]:30303
INFO [03-21|15:05:37] IPC endpoint opened                      url=/Users/hushiwei/Library/Ethereum/geth.ipc
Welcome to the Geth JavaScript console!

instance: Geth/v1.8.2-stable/darwin-amd64/go1.10
 modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大数据框架-开源协议]]></title>
    <link href="http://dmlcoding.com/15209079363420.html"/>
    <updated>2018-03-13T10:25:36+08:00</updated>
    <id>http://dmlcoding.com/15209079363420.html</id>
    <content type="html"><![CDATA[
<p>知道我们经常用的开源框架的开源协议么?</p>

<span id="more"></span><!-- more -->

<table>
<thead>
<tr>
<th>开源项目</th>
<th>开源协议</th>
</tr>
</thead>

<tbody>
<tr>
<td>Superset</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Yanagishima</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Kibana</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Spark</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Tensorflow</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>PlanOut</td>
<td>BSD License</td>
</tr>
<tr>
<td>Hadoop</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Hive</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Sqoop</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Impala</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Presto</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Hbase</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Mysql</td>
<td>GPL license</td>
</tr>
<tr>
<td>Elasticsearch</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>CDH</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Zookeeper</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Hue</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Oozie</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Flume</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Kafka</td>
<td>Apache License 2.0</td>
</tr>
<tr>
<td>Logstash</td>
<td>Apache License 2.0</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zookeeper笔记]]></title>
    <link href="http://dmlcoding.com/15205689785115.html"/>
    <updated>2018-03-09T12:16:18+08:00</updated>
    <id>http://dmlcoding.com/15205689785115.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">基础知识</h2>

<h3 id="toc_1">znode</h3>

<span id="more"></span><!-- more -->

<h3 id="toc_2">基础api</h3>

<pre><code># 创建一个test_node节点,并包含数据testdata
[zk: localhost:2181(CONNECTED) 12] create /test_note testdata
Created /test_note
[zk: localhost:2181(CONNECTED) 13] ls /test_note
[]
[zk: localhost:2181(CONNECTED) 14] get /test_note
testdata
cZxid = 0x1cc0015709f
ctime = Fri Mar 09 12:15:41 CST 2018
mZxid = 0x1cc0015709f
mtime = Fri Mar 09 12:15:41 CST 2018
pZxid = 0x1cc0015709f
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 8
numChildren = 0

[zk: localhost:2181(CONNECTED) 15] delete /test_note
[zk: localhost:2181(CONNECTED) 16] get /test_note
Node does not exist: /test_note

</code></pre>

<h2 id="toc_3">主-从模式的例子</h2>

<pre><code># -e 表示临时性
# 创建一个临时性的znode,节点名称为master_example ,数据为master1.example.com:2223
# 一个临时节点会在会话过期或关闭时自动被删除
create -e /master_example &quot;master1.example.com:2223&quot;

# 列出目录树
ls /

# 获取master_example znode的元数据和数据
get /master_example
</code></pre>

<p>如果再次执行创建master_example的命令会报<code>Node already exists: /master_example</code></p>

<pre><code># 在master_example上设置一个监视点
stat /master_example true
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kafka-sparkstreaming自己维护offset]]></title>
    <link href="http://dmlcoding.com/15203071412162.html"/>
    <updated>2018-03-06T11:32:21+08:00</updated>
    <id>http://dmlcoding.com/15203071412162.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">auto.offset.reset</h2>

<p>By default, it will start consuming from the latest offset of each Kafka partition. If you set configuration auto.offset.reset in Kafka parameters to smallest, then it will start consuming from the smallest offset.</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">OffsetRange</h2>

<p>topic主题,分区ID,起始offset,结束offset</p>

<h2 id="toc_2">重写思路</h2>

<p>因为spark源码中<code>KafkaCluster</code>类被限制在<strong>[spark]</strong>包下,所以我们如果想要在项目中调用这个类,那么只能在项目中也新建包<code>org.apache.spark.streaming.kafka</code>.然后再该包下面写调用的逻辑.这里面就可以引用<code>KafkaCluster</code>类了.这个类里面封装了很多实用的方法,比如:获取主题和分区,获取offset等等...</p>

<p>这些api,spark里面都有现成的,我们现在就是需要组织起来!</p>

<pre><code>offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges
</code></pre>

<p>简单说一下<br/>
1. 在zookeeper上读取offset前先根据实际情况更新<code>fromOffsets</code><br/>
    1.1 如果是一个新的groupid,那么会从最新的开始读<br/>
    1.2 如果是存在的groupid,根据配置<code>auto.offset.reset</code><br/>
        1.2.1 <code>smallest</code> : 那么会从开始读,获取最开始的offset.<br/>
        1.2.2 <code>largest</code> : 那么会从最新的位置开始读取,获取最新的offset.</p>

<ol>
<li>根据topic获取topic和该topics下所有的partitions</li>
</ol>

<pre><code>val partitionsE = kc.getPartitions(topics)
</code></pre>

<ol>
<li>传入上面获取到的topics和该分区所有的partitions</li>
</ol>

<pre><code>val consumerOffsetsE = kc.getConsumerOffsets(groupId, partitions)
</code></pre>

<ol>
<li>获取到该topic下所有分区的offset了.最后还是调用spark中封装好了的api</li>
</ol>

<pre><code>KafkaUtils.createDirectStream[K, V, KD, VD, (K, V, String)](
                ssc, kafkaParams, consumerOffsets, (mmd: MessageAndMetadata[K, V]) =&gt; ( mmd.key, mmd.message, mmd.topic))
</code></pre>

<ol>
<li>更新zookeeper中的kafka消息的偏移量</li>
</ol>

<pre><code>kc.setConsumerOffsets(groupId, Map((topicAndPartition, offsets.untilOffset)))
</code></pre>

<h2 id="toc_3">问题</h2>

<p>sparkstreaming-kafka的源码中是自己把offset维护在kafka集群中了?</p>

<pre><code>./kafka-consumer-groups.sh --bootstrap-server 10.10.25.13:9092 --describe  --group heheda
</code></pre>

<p>因为用命令行工具可以查到,这个工具可以查到基于javaapi方式的offset,查不到在zookeeper中的</p>

<p>网上的自己维护offset,是把offset维护在zookeeper中了?<br/>
用这个方式产生的groupid,在命令行工具中查不到,但是也是调用的源码中的方法呢?<br/>
难道spark提供了这个方法,但是自己却没有用是吗?</p>

<h2 id="toc_4">自己维护和用原生的区别</h2>

<p>区别只在于,自己维护offset,会先去zk中获取offset,逻辑处理完成后再更新zk中的offset.<br/>
然而,在代码层面,区别在于调用了不同的<code>KafkaUtils.createDirectStream</code></p>

<h3 id="toc_5">自己维护</h3>

<p>自己维护的offset,这个方法会传入offset.因为在此之前我们已经从zk中获取到了起始offset</p>

<pre><code>KafkaUtils.createDirectStream[K, V, KD, VD, (K, V, String)](
                ssc, kafkaParams, consumerOffsets, (mmd: MessageAndMetadata[K, V]) =&gt; ( mmd.key, mmd.message, mmd.topic))
</code></pre>

<h3 id="toc_6">原生的</h3>

<p>接受的是一个topic,底层会根据topic去获取存储在kafka中的起始offset</p>

<pre><code>KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](ssc, kafkaParams, myTopic)
</code></pre>

<p>接下来这个方法里面会调用<code>getFromOffsets</code>来获取起始的offset</p>

<pre><code>val kc = new KafkaCluster(kafkaParams)
val fromOffsets = getFromOffsets(kc, kafkaParams, topics)
</code></pre>

<h2 id="toc_7">代码</h2>

<p>这个代码,网上很多,GitHub上也有现成的了.这里我就不贴出来了!<br/>
这里主要还是学习代码的实现思路!</p>

<h2 id="toc_8">如何引用spark源码中限制了包的代码</h2>

<ol>
<li>新建和源码中同等的包名,如上所述.</li>
<li>把你需要的源码拷贝一份出来,但是可能源码里面又引用了别的,这个不一定好使.</li>
<li>在你需要引用的那个类里,把这个类的包名改成与你需要引用的包名一样.最简单的办法了</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查看linux系统负荷]]></title>
    <link href="http://dmlcoding.com/15202200627560.html"/>
    <updated>2018-03-05T11:21:02+08:00</updated>
    <id>http://dmlcoding.com/15202200627560.html</id>
    <content type="html"><![CDATA[
<h1 id="toc_0">uptime</h1>

<pre><code>~ uptime
17:54:40 up 846 days, 55 min, 10 users,  load average: 0.36, 0.33, 0.48
</code></pre>

<span id="more"></span><!-- more -->

<ul>
<li>这行信息的后半部部分,显示 **load average.  **它的意思是系统的平均负荷.</li>
<li>通过里面的三个数字,我们可以从中判断系统负荷是大还是小</li>
<li>这3个数字,分别代表1分钟,5分钟,15分钟内系统的平均负荷.</li>
<li>当CPU完全空闲的时候,平均负荷为0;当CPU工作量饱和的时候,平均负荷为1(假设只有一个核)</li>
<li>那么很显然,load average的值越低,比如0.2或者0.3,就说明电脑的工作量越小,系统负荷比较轻</li>
</ul>

<p>参考文档</p>

<p><a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages">http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages</a></p>

<p>总结:</p>

<p>假设服务器有16个核.</p>

<p>那么当load average的值小于16的时候,表示现在系统负荷轻.当load average的值大于16就表示负荷过大了.</p>

<p>查看服务器有多少个CPU核心</p>

<p><u><strong>grep -c &#39;model name&#39; /proc/cpuinfo</strong></u></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MacbookPro 修改应用的默认语言]]></title>
    <link href="http://dmlcoding.com/15202199373374.html"/>
    <updated>2018-03-05T11:18:57+08:00</updated>
    <id>http://dmlcoding.com/15202199373374.html</id>
    <content type="html"><![CDATA[
<p>当我把macbook pro的默认系统语言从中文改成英文后,其他的应用的语言也都变成了英文了.</p>

<p>但是比如地图应用,我还是希望用中文呢?</p>

<h1 id="toc_0">将地图Maps应用的语言改成中文</h1>

<span id="more"></span><!-- more -->

<p>第一步</p>

<pre><code>You don&#39;t need to change language setting. 
You can simply set it in the Maps App&#39;s Menu at [View]-&gt; [Labels]-&gt; [Always Show Labels in English].
 Then cancel it.
</code></pre>

<p>第二步</p>

<pre><code>defaults write com.apple.Maps AppleLanguages &#39;(zh-CN)&#39;
</code></pre>

<hr/>

<pre><code># 英文 -&gt; 简体中文
defaults write com.google.Chrome AppleLanguages &#39;(zh-CN)&#39;

# 简体中文 -&gt; 英文
defaults write com.google.Chrome AppleLanguages &#39;(en-US)&#39;

# 英文优先，简体中文第二。反之改一下顺序
defaults write com.google.Chrome AppleLanguages &quot;(en-US,zh-CN)&quot;
</code></pre>

<h1 id="toc_1">Calendar</h1>

<pre><code>defaults write com.apple.iCal AppleLanguages &#39;(zh-CN)&#39;
</code></pre>

<p>那么问题来了,从上面可以知道只要修改每个应用的系统语言即可</p>

<h1 id="toc_2">如何找到应用的包名</h1>

<p>以<strong>滴答清单</strong>为例</p>

<pre><code># 在&quot;&quot;双引号中输入应用名称,执行下面的命令即可返回应用的包名
hushiwei@hsw ~  osascript -e &#39;id of app &quot;Wunderlist&quot;&#39;
com.wunderkinder.wunderlistdesktop
</code></pre>

<p>知道了应用的包名,那么就可以执行上面的命令来修改应用的语言了</p>

<pre><code>defaults write com.wunderkinder.wunderlistdesktop AppleLanguages &#39;(zh-CN)&#39;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[思考]]></title>
    <link href="http://dmlcoding.com/15199545224004.html"/>
    <updated>2018-03-02T09:35:22+08:00</updated>
    <id>http://dmlcoding.com/15199545224004.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">为什么有些人能够突飞猛进?</h2>

<ul>
<li>智商高</li>
<li>有想法,有思路</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kafka-sparkstreaming长时间运行后异常退出原因分析]]></title>
    <link href="http://dmlcoding.com/15199040835190.html"/>
    <updated>2018-03-01T19:34:43+08:00</updated>
    <id>http://dmlcoding.com/15199040835190.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">报错信息</h2>

<pre><code>Couldn`t find leader offsets for set([xxxxxxxxxxx,xx])

# 或者
numRecords must not be negative
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">分析过程</h2>

<p>从博客中已经找不到直接的解决方案，那么只能从源码入手，从而看看能不能定位到问题所在。<br/>
从这一行代码开始跟踪</p>

<pre><code>KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder](ssc, kafkaParams, myTopic)

</code></pre>

<p>发现了,先调用<code>getFromOffsets(kc, kafkaParams, topics)</code>获取到了起始offset.然后创建了一个<br/>
<code>DirectKafkaInputDStream</code>对象.点进去</p>

<pre><code>  def createDirectStream[
    K: ClassTag,
    V: ClassTag,
    KD &lt;: Decoder[K]: ClassTag,
    VD &lt;: Decoder[V]: ClassTag] (
      ssc: StreamingContext,
      kafkaParams: Map[String, String],
      topics: Set[String]
  ): InputDStream[(K, V)] = {
    val messageHandler = (mmd: MessageAndMetadata[K, V]) =&gt; (mmd.key, mmd.message)
    val kc = new KafkaCluster(kafkaParams)
    val fromOffsets = getFromOffsets(kc, kafkaParams, topics)
    new DirectKafkaInputDStream[K, V, KD, VD, (K, V)](
      ssc, kafkaParams, fromOffsets, messageHandler)
  }

</code></pre>

<p>找到这个对象里面的<code>compute</code>方法,重点从这个方法的逻辑开始分析</p>

<pre><code>  override def compute(validTime: Time): Option[KafkaRDD[K, V, U, T, R]] = {
    val untilOffsets = clamp(latestLeaderOffsets(maxRetries))
    val rdd = KafkaRDD[K, V, U, T, R](
      context.sparkContext, kafkaParams, currentOffsets, untilOffsets, messageHandler)

    // Report the record number and metadata of this batch interval to InputInfoTracker.
    val offsetRanges = currentOffsets.map { case (tp, fo) =&gt;
      val uo = untilOffsets(tp)
      OffsetRange(tp.topic, tp.partition, fo, uo.offset)
    }
    val description = offsetRanges.filter { offsetRange =&gt;
      // Don&#39;t display empty ranges.
      offsetRange.fromOffset != offsetRange.untilOffset
    }.map { offsetRange =&gt;
      s&quot;topic: ${offsetRange.topic}\tpartition: ${offsetRange.partition}\t&quot; +
        s&quot;offsets: ${offsetRange.fromOffset} to ${offsetRange.untilOffset}&quot;
    }.mkString(&quot;\n&quot;)
    // Copy offsetRanges to immutable.List to prevent from being modified by the user
    val metadata = Map(
      &quot;offsets&quot; -&gt; offsetRanges.toList,
      StreamInputInfo.METADATA_KEY_DESCRIPTION -&gt; description)
    val inputInfo = StreamInputInfo(id, rdd.count, metadata)
    ssc.scheduler.inputInfoTracker.reportInfo(validTime, inputInfo)

    currentOffsets = untilOffsets.map(kv =&gt; kv._1 -&gt; kv._2.offset)
    Some(rdd)
  }
</code></pre>

<p>分析过程不仔细说了,感兴趣的在compute方法处打个断点,跟踪一下相关变量的值,应该就能明白一个大概了.</p>

<h2 id="toc_2">解决办法</h2>

<p>综上所述,解决办法为添加以下参数:</p>

<pre><code>--conf spark.streaming.kafka.maxRetries=50 \
--conf spark.yarn.maxAppAttempts=10 \
--conf spark.yarn.am.attemptFailuresValidityInterval=1h \
</code></pre>

<p>注意:<br/>
1. spark.yarn.maxAppAttempts参数不能超过hadoop集群yarn.resourcemanager.am.max-attempts的最大值，如果超过将会取两者较小值<br/>
2. 由于kafka切换leader导致的数据丢失,然后造成sparkstreaming程序报错,异常退出的情况下.我这通通常都是重启kafka,删除checkpoint,再重启sparkstreaming了.<br/>
3. 后面我们不用原生的方式来存储offset.而是自己维护offset,那么以后更新迭代后就不用再删除checkpoint了,对业务的影响也最小了.</p>

]]></content>
  </entry>
  
</feed>
